package subgroup

import (
  "fmt"
  "math"
  "strconv"

  "github.com/spf13/cobra"

  "github.com/timebertt/grypto/modular"
)

func NewCommand() *cobra.Command {
  var base, mod int32

  cmd := &cobra.Command{
    Use:   "subgroup [base] [modulus]",
    Short: "Calculate the multiplicative subgroup generated by base modulo mod",
    Long: `SubgroupOf calculates the multiplicative subgroup generated by base modulo mod.
The subgroup for an element g in ℤₐ (denoted as ⟨g+aℤ⟩) contains all elements g^x mod a with x ∈ ℤ.
The calculation stops once it encounters 0 as any g^x mod a.

See https://en.wikipedia.org/wiki/Subgroup`,
    Args: cobra.ExactArgs(2),
    PreRunE: func(cmd *cobra.Command, args []string) error {
      b, err := strconv.Atoi(args[0])
      if err != nil {
        return fmt.Errorf("first argument is not an int: %w", err)
      }
      if b > math.MaxInt32 {
        return fmt.Errorf("base is greater than MaxInt32 (%d): %d", math.MaxInt32, b)
      }
      base = int32(b)

      m, err := strconv.Atoi(args[1])
      if err != nil {
        return fmt.Errorf("second argument is not an int: %w", err)
      }
      if m > math.MaxInt32 {
        return fmt.Errorf("modulus is greater than MaxInt32 (%d): %d", math.MaxInt32, b)
      }
      mod = int32(m)

      cmd.SilenceErrors = true
      cmd.SilenceUsage = true

      return nil
    },
    RunE: func(cmd *cobra.Command, args []string) error {
      return runSubgroup(base, mod)
    },
  }

  return cmd
}

func runSubgroup(base, mod int32) (err error) {
  defer func() {
    if p := recover(); p != nil {
      if e, ok := p.(error); ok {
        err = e
      }
      if e, ok := p.(string); ok {
        err = fmt.Errorf(e)
      }
    }
  }()

  for i, e := range modular.SubgroupOf(base, mod) {
    fmt.Printf("%d ^ %d mod %d = %d\n", base, i, mod, e)
  }

  return nil
}
