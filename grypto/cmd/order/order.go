package order

import (
  "fmt"
  "math"
  "strconv"

  "github.com/spf13/cobra"

  "github.com/timebertt/grypto/modular"
)

func NewCommand() *cobra.Command {
  var base, mod int32

  cmd := &cobra.Command{
    Use:   "order [base] [modulus]",
    Short: "Calculate the order of base in the residue system modulo mod",
    Long: `order calculates the order of base in the residue system modulo mod.
In ℤₐ the order of an element g is defined as the smallest integer l, so that g^l ≡ 1 mod a, if such l exists.
If not, the order of g is infinite.
Also, the order of g in ℤₐ is equal to the magnitude of the multiplicative subgroup generated by g modulo a:
order(g) = order(⟨g+aℤ⟩) = |⟨g+aℤ⟩|

See https://en.wikipedia.org/wiki/Order_(group_theory)`,
    Args: cobra.ExactArgs(2),
    PreRunE: func(cmd *cobra.Command, args []string) error {
      b, err := strconv.Atoi(args[0])
      if err != nil {
        return fmt.Errorf("first argument is not an int: %w", err)
      }
      if b > math.MaxInt32 {
        return fmt.Errorf("base is greater than MaxInt32 (%d): %d", math.MaxInt32, b)
      }
      base = int32(b)

      m, err := strconv.Atoi(args[1])
      if err != nil {
        return fmt.Errorf("second argument is not an int: %w", err)
      }
      if m > math.MaxInt32 {
        return fmt.Errorf("modulus is greater than MaxInt32 (%d): %d", math.MaxInt32, b)
      }
      mod = int32(m)

      return nil
    },
    RunE: func(cmd *cobra.Command, args []string) error {
      return runOrder(base, mod)
    },
  }

  return cmd
}

func runOrder(base, mod int32) (err error) {
  defer func() {
    if p := recover(); p != nil {
      if e, ok := p.(error); ok {
        err = e
      }
      if e, ok := p.(string); ok {
        err = fmt.Errorf(e)
      }
    }
  }()

  order, inf := modular.OrderOf(base, mod)
  o := strconv.FormatInt(int64(order), 10)
  if inf {
    o = "Inf"
  }

  fmt.Printf("order(%d) = %s mod %d\n", base, o, mod)
  return nil
}
