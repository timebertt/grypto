package modular

// SubgroupMaxMod is the maximum mod value accepted in SubgroupOf.
const SubgroupMaxMod = 1 << 22

// SubgroupOf calculates the multiplicative subgroup generated by base modulo mod.
// The subgroup for an element g in ℤₐ (denoted as ⟨g+aℤ⟩) contains all elements g^x mod a with x ∈ ℤ.
// The calculation stops once it encounters 0 as any g^x mod a.
// See https://en.wikipedia.org/wiki/Subgroup
func SubgroupOf(base, mod int32) []int32 {
  if base <= 0 {
    panic("grypt/modular: base must be greater than 0")
  }
  if mod <= 0 {
    panic("grypto/modular: modulus must be greater than 0")
  }
  if mod > SubgroupMaxMod {
    // be conservative here, this slice implementation is very inefficient and can quickly become a memory hog
    panic("grypto/modular: modulus too large")
  }

  var (
    g   = make([]int32, 0, mod)
    exp = int64(1)
    i   = int32(0)
    b   = int64(base % mod)
    m   = int64(mod)
  )

  for ; i <= mod; i++ {
    if i > 0 && exp == 1 {
      break
    }
    g = append(g, int32(exp))
    if exp == 0 {
      return g // exponentiation won't change anymore
    }

    exp = exp * b % m
  }

  return g
}
