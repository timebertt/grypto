package modular

// OrderOf calculates the order of base in the residue system modulo mod.
// In ℤₐ the order of an element g is defined as the smallest integer l, so that g^l ≡ 1 mod a, if such l exists.
// If not, the order of g is infinite.
// Also, the order of g in ℤₐ is equal to the magnitude of the multiplicative subgroup generated by g modulo a:
// order(g) = order(⟨g+aℤ⟩) = |⟨g+aℤ⟩|
// See https://en.wikipedia.org/wiki/Order_(group_theory)
func OrderOf(base int32, mod int32) (order int32, inf bool) {
  if base <= 0 {
    panic("grypt/modular: base must be greater than 0")
  }
  if mod <= 0 {
    panic("grypto/modular: modulus must be greater than 0")
  }

  var (
    exp = int64(1)
    i   = int32(0)
    b   = int64(base % mod)
    m   = int64(mod)
  )

  for ; i <= mod; i++ {
    if i > 0 && exp == 1 {
      break
    }
    if exp == 0 {
      // once base^i = 0, it won't change anymore =>  order(base) = Inf
      return 0, true
    }

    exp = exp * b % m
  }

  return i, false
}

const SubgroupMaxMod = 1 << 22

// SubgroupOf calculates the multiplicative subgroup generated by base modulo mod.
// The subgroup for an element g in ℤₐ (denoted as ⟨g+aℤ⟩) contains all elements g^x mod a with x ∈ ℤ.
// The calculation stops once it encounters 0 as any g^x mod a.
// See https://en.wikipedia.org/wiki/Subgroup
func SubgroupOf(base int32, mod int32) []int32 {
  if base <= 0 {
    panic("grypt/modular: base must be greater than 0")
  }
  if mod <= 0 {
    panic("grypto/modular: modulus must be greater than 0")
  }
  if mod > SubgroupMaxMod {
    // be conservative here, this slice implementation is very inefficient and can quickly become a memory hog
    panic("grypto/modular: modulus too large")
  }

  var (
    g   = make([]int32, 0, mod)
    exp = int64(1)
    i   = int32(0)
    b   = int64(base % mod)
    m   = int64(mod)
  )

  for ; i <= mod; i++ {
    if i > 0 && exp == 1 {
      break
    }
    g = append(g, int32(exp))
    if exp == 0 {
      return g // exponentiation won't change anymore
    }

    exp = exp * b % m
  }

  return g
}
